# Сортировка мин-кучей

# H - {} - мин-куча
# for i in range(1,n):
#   Insert(H,A[i])
# for i in range(1,n):
# A'[i] = ExtractMin(H)
#
#
# TODO


# Сортировка кучей "На месте"

# BuildMaxHeap(A) - сделаем макс-кучу из массива А
# size = n  - отвечает за то, в какой части массива лежит куча
# for i in range(n,2):
#   swap (A[size],A[1])
#   size = size-1
#   SiftDown(A,1)

# переставляем элемент с позиции size в начало, а на его место ставим максимальный
# (первый/корень) элемент. Сокращаем size, справа остается отсортированная часть,
# и "Утапливаем" элемент, который мы вытащили на первое место

# def BuildMaxHeap(A[]):
#    for i in range(math.floor(n/2),1):
#    SiftDown(A,i)

# TODO

#######
# Сортировки, основанные не на сравнениях

# Сортировка подсчетом
# 2 1 1 1 3 2 2 2 3 2 3 2 2 1 1
# 5 7 3
# 1 1 1 1 1 2 2 2 2 2 2 2 3 3 3

# массив А содержит целые числа от 1 до М
# Создать массив В[1..M] = [0,..0]
# for j in range(1,n):
#   B[A[j]]=B[A[j]]+1 ## сколько раз каждый элемент встречается в массиве
# for i in range(2,M):
#   B[i]=B[i]+B[i-1] ## Кол-во раз, в А свтреч.числа <= i
# for j in range(n,1):
#   A'[B[A[j]]]=A[j] # кладем элемент по индексу самого правого
#                   возможного положения этого элемента
#   B[A[j]]=B[A[j]]-1

# Равные элементы идут в той же последовательности, что и были в исх.

# Идем по элементам справа налево, и при встрече нового элемента
# кладем его в макс.правое для него положение

# время работы O(n +M)