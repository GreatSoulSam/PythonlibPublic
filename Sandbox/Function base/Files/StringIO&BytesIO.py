#
#
#
#Класс StringiO из модуля io nозволяет работать со строкой как с файловым объектом.
# Все оnерации с файловым объектом nроизводятся в оnеративной nамяти.
# Формат конструктора класса:
#StringIO([<Haчaльнoe значение>][, newline=None])

#default начальное значение - пустая строка

#Методы возвращаемого объекта:

#close () -закрывает "файл". Проверить, открыт "файл" или закрыт, nозволяет атрибут
# closed. Атрибут возвращает True, если "файл" был закрыт, и False в nротивном случае;

# getvalue () -возвращает содержимое "файла" в виде строки:

#import io # Подключаем модуль
#f = io.StringiO("Stringl \n")
#f .getvalue () # Получаем содержимое файла
'Stringl\n'
#f.close() # Закрываем файл

# tell () -возвращает текущую nозицию указателя относительно начала "файла";

# seek (<Смещение> [, <Позиция> J ) - устанавливает указатель в nозицию,
# имеющую смещение #<Смещение> относительно nозиции <Позиция>.
# В nараметре <Позиция> могут бытьуказаны следующие значения:
#   • 0 - начало "файла" (значение no умолчанию);
#   • 1 - текущая nозиция указателя;
#   • 2 - конец "файла".

#write (<Строка>) -заnисывает стРоку в "файл":

# writelines (<Последовательность>) -записывает последовательность в "файл":
import io
f = io.StringIO()
f.writelines(["Stringl\n", "String2\n"])
print(f.getvalue()) # Получаем содержимое файла
# 'Stringl\nString2\n '
f.close() # Закрываем файл

#read ( [<Количество символов> J) -считывает данные из "файла".
# Если nараметр не указан, то возвращается содержимое "файла" от текущей nозиции
# указателя до конца "файла". Если в качестве nараметра указать число,
# то за каждый вызов будет возвращаться указанное количество символов.

#readline ( [<Количество символов>]) - считывает из "файла" одну строку
# nри каждом вызове.

#__next__ () -считывает одну строку при каждом вызове. При достижении конца "файла"
#возбуждается исключение Stoprteration.
#Благодаря методу _next_() мы можем перебирать файл построчно с помощью цикла for.

f = io.StringIO("String1\nString2")
for line in f:
    print(line.rstrip())
f.close()

print()

#flush () -сбрасывает данные из буфера в "файл";

#truncate ( [<Количество символов> J ) - обрезает "файл" до указанного
# количества символов.

#Класс StringiO работает 'только со строками. Чтобы выполнять аналогичные операции
#с последовательностями байтов, следует использовать класс Bytesro из модуля io.
# Формат конструктора класса:
#ВуtеsIО([<Начальное значение>])
#Класс BytesrIO содержит такие же методы, что и класс StringIO,
# но в качестве значений#методы принимают и возвращают последовательности
# байтов, а не строки.

#Новые методы:
# getbuffer () - возвращает
# ссылку на объект meinoryview. С помощью этого объекта можно получать и
# изменять данные по индексу или срезу, преобразовывать данные в список
# целых чисел (с помощью метода tolist()) или в последовательность байтов
# (с помощью метода tobytes () ).

#f = io.BytesIO(b"Python")
#buf = f.getbuffer()
#a = buf[0] # Получаем значение по индексу
#b'Р'
#buf[0] = b"J"
#f .getvalue ()
#b'Jython'
#buf.tolist()
#[74, 121, 116, 104, 111,110]
#buf.tobytes()
#b'Jython'
#f.close()
# Изменяем значение по индексу
# Получаем содержимое
# Преобразуем в сnисок чисел

# Преобразуем в тиn bytes
# Закрьшаем файл

#not working, but i don't care

