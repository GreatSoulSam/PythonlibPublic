#
#
#
#

#c1ose () -закрывает файл.

#write(<Данные>) записывает строку или последовательность байтов в файл.
# Если в качестве nараметра указана строка, то файл должен быть открыт
# в текстовом режиме.

f = open(r"file.txt", "w", encoding="cp1251")
f.write("Cтpoкa1\nCтpoкa2") # Записываем строку в файл
#15
f.close() # Закрываем файл

# Бинарный режим
f = open(r"file.txt", "wb")
f .write (bytes ("Строка1\nСтрока2", "cp1251"))
#15
f.write (bytearray("\nCтpoкaЗ", "cp1251"))
#8
f.close()

#writelines (<Последовательность>) -записывает последовательность в файл.
# Если все элементы последовательности являются строками, то файл
# должен быть открыт в текстовом режиме. Если посл-тями байтов, то в бинарном режиме

# ТекстовьМ режим
f = open(r"file1.txt", "w", encoding="cp1251")
f.writelines(["Cтpокa1\n", "Строка2"])
f.close()

# Бинарньм режим
f = open(r"file1.txt", "wb")
arr = [bytes ( "Строка1 \n", "cp1251"), bytes ( "Строка2", "cp1251")]
f.writelines(arr)
f.close()

#read( [<Количество>])- считывает данные из файла. Если файл открыт в текстовом
#режиме, то возвращается строка, а если в бинарном - последовательность байтов.
# Если параметр не указан, то возвращается содержимое файла от текущей позиции
# указателя до конца файла
print("read")
# Текстовый режим
with open(r"file.txt", "r", encoding="cp1251") as f:
    f.read()
'Строка1\nСтрока2'
# Бинарный режим
with open(r"file.txt", "rb") as f:
   a= f.read()
print(a)

#Если в качестве параметра указать число, то за каждый вызов будет возвращаться
# указанное количество символов или байтов. Когда достигается конец файла,
# метод возвращает пустую строку.

# Текстовый режим
f = open(r"file.txt", "r", encoding="cp1251")
a = f.read(8) # Считываем в символов
print(a)
a = f.read(8) # Считываем в символов
print(a)
a = f.read(8) # Считываем в символов
print(a)
a = f.read(8) # Достигнут конец файла
print(a,"достигли конца файла")
f.close()

#readline ( [<Количество> J) -считывает из файла одну строку при каждом вызове.
# Если файл открыт в текстовом режиме, то возвращается строка, а если в
# бинарном- последовательность байтов. Возвращаемая строка включает
# символ перевода строки. Исключением является последняя строка.
# Если она не завершается символом перевода строки, то символ перевода строки
# добавлен не будет. При достижении конца файла возвращается пустая строка.

print("\nreadline")
# Текстовьм режим
f = open(r"file.txt", "r", encoding="cp1251")
a=f.readline(), f.readline()
print(a)
#('Строкаl\n', 'Строка2')

#readlines () - считывает все содержимое файла в список. Каждый элемент списка
# будет содержать одну строку, включая символ перевода строки.
#возвращается список строк или список объектов типа bytes

print("\nreadlines")
# Текстовьм режим
with open(r"file.txt", "r", encoding="cp1251") as f:
    a=f.readlines ()
print(a)

#__next__() - считывает одну строку при каждом вызове. Если файл открыт в текстовом
# режиме, то возвращается строка, а если в бинарном - последовательность байтов.
# При достижении конца файла возбуждается исключение Stopiteration

print("\n__next__")
# Текстовьм режим
f = open(r"file.txt", "r", encoding="cp1251")
a = f.__next__ (), f. __next__ (),f. __next__ ()
print(a)
#f.__next__ () #Достигнут конец файла
#Stopiteration
f.close ()

#flush() - записывает данные из буфера на диск

#truncate ( [<Количество>]) - обрезает файл до указанного количества символов
# или байтов. Метод возвращает новый размер файла.
print("\ntruncate")
f = open(r"file.txt", "r+", encoding="cp1251")
a = f.read ( )
print(a)
f.truncate(5)
f.close()
print("а теперь что получилось после обрезки")
with open(r"file.txt", "r", encoding="cp1251") as f:
    a = f.read ()
print(a)

# tell () - возвращает позицию указателя относительно начала файла в виде
# целого числа. B Windows метод tell() считает символ \r как дополнительный
# байт, хотя этот символ удаляется при открытии файла в текстовом режиме.

print("\ntell")
with open(r"file.txt", "w", encoding="cp1251") as f:
    f.write ( "String1 \nString2")
#15
f = open(r"file.txt", "r", encoding="cp1251")
f.tell() #Указатель расположен в начале файла
#0
print(f.readline()) # Перемещаем указатель
#'String1\n'
f.tell() #Возвращает 9 (8 + '\r'), а не 8 ! ! !
#9
f. close ()


#seek (<Смещение> [, <Позиция>]) - устанавливает указатель в позицию,
# имеющую смещение <Смещение> относительно позиции <Позиция>.
# В параметре <Позиция> могут быть указаны следующие атрибуты из модуля
# io или соответствующие им значения:
#• io.SEEK_SET или 0 - начало файла (значение по умолчанию);
#• io. SEEK_CUR или 1 - текущая позиция указателя;
#• io. SEEK_END или 2 - конец файла.

print("\nseek")

import io
print(io.SEEK_SET,io.SEEK_CUR,io.SEEK_END)

f = open(r"file.txt","rb")
f.seek(9, io.SEEK_CUR)# 9 байтов от указателя
print(f.tell())
f.seek(0,io.SEEK_SET) # в начало
print(f.tell())
f .seek(-9, io.SEEK_END) # -9 байтов от конца файла
print(f.tell())
f.close()


##################################################
#Другие подерживаемые атрибуты
# name- содержит название файла;
# mode- режим, в котором был открыт файл;
# closed- возвращает True, если файл был закрыт, и False в противном случае.
# encoding - название кодировки, только для чтения, только в текстовом режиме
#buffer - позволяет получить доступ к буферу. Текст онли. Можно записать последть байтов
# в текстовый поток
print("\nатрибуты файлов")
f = open(r"file.txt","r+b")
print(f.name,f.mode,f.closed)
f.close()
print(f.closed)

print()
print("\nbuffer example")
f = open(r"file.txt","w",encoding="cp1251")
print(f.buffer.write(bytes("Строка","cp1251")))
f.close()


