# Словари

#оздание словаря
#diсt(<Ключ1>=<Значение1>[, ... , <КлючN>=<ЗначениеN>])
#diсt(<Словарь>)
#diсt(<Список кортежей с двумя элементами (Ключ, Значение)>)
#diсt(<Список списков с двумя элементами [Ключ, Значение]>)

d = dict()
print(d)
d = dict(a=1, b=2)
print(d)
d = dict([("a",1),(("b",2))])
print(d)
d = dict((["a",1],["b",2]))
print(d)

#zip - объединение двух списков в список кортежей
k = ["a","b"]
v = [1,2]
print(list(zip(k,v)))
d = dict(zip(k,v))
print(d)

#Все элементы внутри фигурных скобок
d = {}
d = {"а": 1, "b": 2}
print(d)

#поэлементное заполнение
d = {} # Создаем пустой словарь
d["a"] = 1 # Добавляем элемент1 (КЛЮЧ "а")
d["b"] = 2 # Добавляем элемент2 (ключ "Ь")
print(d)

#dict.fromkeys((<Последовательность> [, <Значение>] )
print("\nfromkeys")
d = dict.fromkeys(["a", "Ь", "с"])
print(d)
d = dict.fromkeys(["a", "Ь", "с"], 0) #Указан спис;ок
print(d)
d = dict.fromkeys(("a", "Ь", "с"), 0)# Указан кортеж
print(d)

#При создании словаря в переменной сохраняется ссылка на объект, а не сам объект.
#Групповое присваиванне можно использовать для чисел и строк,
# но для списков и словарей этого делать нельзя.

d1 = d2 = { "а": 1, "b": 2 } # Якобы создали два объекта
d2["b"] = 10
print(d1,d2) # изменились оба, тк. ссылка на один объект

#полная копия - deepcopy()

# Операции над словарями
#выведем все элементы
d= { 1: "int", "a": "str", (1, 2): "tuple"}
print(d[1], d["a"], d[ (1, 2)])

d = {"а": 1, "b": 2}
print("b" in d)
print("c" in d)

#get(<Ключ> [, <Значение no умолчанию>])
#Если ключ присутствует в словаре, то метод возвращает
# значение, соответствующее этому ключу. Если ключ отсутствует,
# то возвращается None или значение, указанное во втором nараметре.

d = { "a": 1, "b": 2 }
print(d.get("a"), d.get("c"), d.get("c", 800))

#setdefault(<Кrnoч>[, <Значение по умолчанию>]).
#Если ключ присутствует в словаре, то метод возвращает значение, соответствующее
#этому ключу. Если ключ отсутствует, то вставляет новый элемент,
# со значением, указанным во втором nараметре. Если второй параметр не указан,
# значением нового элемента будет None.
d = { "a": 1, "b": 2 }
print(d.setdefault("a"), d.setdefault("c"), d.setdefault("d", 0))
print(d)

#Изменение данных по индексу и добавление данных
d= {"a": 1, "b": 2}
d["a"] = 800
d["c"]= "string"
print(d)

#число ключей в словаре:
print(len(d)," число ключей Len()")

#удаление по ключу
del d["b"]
print(d)


#Перебор элементов словаря
print("Перебор элементов словаря\n")
d = {"х": 1, "у": 2, "z": 3}
for key in d.keys():
    print("({0} => {1})".format(key,d[key]),end = " ")
print()

for key in d:
    print("({0} => {1})".format(key, d[key]), end=" ")

print()
#Сортировка
d = {"х": 1, "у": 2, "z": 3}
k = list(d.keys()) #Получаем список ключей
k.sort( ) # Сортируем список ключей
for key in k:
    print("({0} => {1})".format(key, d[key]), end=" ")

#ТАкже моно использовать Sorted()

#Методы для работы со словарями

#keys() - возвращает объект dict_keys, поддерж. итерации и содержаий все ключи словаря

#values() - аналогично, только значенеия.

#items() - все значения и ключи в виде кортежей

#<Ключ> in <Словарь>- проверяет существование указанного клlоча в словаре

#get (<Ключ> [, <Значение по умолчанию>]) -если ключ присутствует в словаре,
# то метод возвращает значение, соответствующее этому ключу.
# Если ключ отсутствует, то возвращается значение None или значение,
# указанное во втором параметре.

#setdefau1 t (<Ключ> [, <Значение по умолчанию>] } - если ключ есть в словаре,
#то метод возвращает соответствующее ему значение. Иначе - создает новый эл-т,
#со значением DefaultValue. По умолчанию - None

#рор (<Ключ> [, <Значение по умолчанию>]) - удаляет элемент с указанным ключом и
#возвращает его значение.

#popitem()- удаляет произвольный элемент и возвращает кортеж из ключа и значения.
print()
d = { "а": 1, "b": 2 ,"c":3}
print(d)
d.popitem() # Удаляем произвольный элемент
print(d)

# Но по факту удаляется последний

#c1ear () -удаляет все элементы словаря.

#update () - добавляет элементы в словарь
# uрdаtе(<Ключ1>=<Значение1>[, ... , <КлючN>=<ЗначениеN>])
# uрdаtе(<Словарь>)
# update(<Cnиcoк кортежей с двумя элементами>)
# update(<Cnиcoк елисков с двумя элементами>)


###############
#Генераторы словарей
keys = ["a", "b", "c"]
values = (1,2,3)
print({k: v for (k,v) in zip(keys,values)})

print({k: 0 for k in keys})


#############################################
#Множества
# - неупоряд.коллекция уникальных элементов

s = set()
print(s)

print(set("string"))
print(set([1, 2, 3, 1, 2, 3]))

#получить элеемнты
for i in set([1, 2, 3]):
    print(i, end=" ")
print()

#len() - без изменений

##################################################
#Методы для работы с множествами

#  | и union() -объединение множеств:
s = {1, 2, 3}
print(s.union(set([4, 5, 6])), s | set([4, 5, 6]))

print(set([1, 2, 3]) | set([1, 2, 3]))

#а |= b и а.update(b) -добавляют элементы множества b во множество а:

s = {1,2,3}
s.update(set([4,5,6]))
print(s)
s |= set([7,8,9])
print(s)

# - и difference() - разница множеств
print(set([1,2,3])-set([1,2,4]))

#а -= b и а.difference upciate(b) -удаляют элементы из множества а,
# которые существуют и во множестве а, и во множестве ь:
s = {1,2,3,4}
s-=set([3,6,1,7])
print(s)

# & и intersection() - пересечение множеств
print(set ( [ 1 , 2 , 3] ) & set ( [ 1 , 2, 4 ] ))

# a &= b и а.intersection_update(b) -во множестве а останутся элементы пересеченя
# - по аналогии

# ^ и symmetric_difference() - всё кроме общих элементов
# ^= и a = symmetric_difference(b) - по аналогии

# также: in, ==, a<=b или a.issubset(b), a<b, a>=b или a.issuperset(b), a>b,
# a.isdisjoint(b) - True если мн-ва не пересекаются

#add(<element>) / remove(<element>) _добавление/удаление

# discard(<ELEMENT>) - удаляет, если есть такой элемент

# pop() - удаляет произвольный и возвращает его

#clear() - удаляет всё


##Генераторы:
s={x for x in [1,2,1,2,1,2,3,4,5,6,8,0] if x%2 ==0}
print(s)
